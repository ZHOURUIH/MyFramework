运行游戏
1.克隆项目
2.用unity打开,如果编辑器有报错,则解决报错.
3.可能需要手动安装Obfuz和HybridCLR,具体安装方式可以查看官网
https://www.obfuz.com/docs/manual/installation
https://www.hybridclr.cn/docs/basic/install
4.在unity中按F5开始运行游戏.F5,F6,F7分别对应运行,暂停,单步运行三个按钮.F5会自动打开start.unity场景并且开始运行游戏.
  提示:一般我习惯按F5以后自动跳转到Game视图,如果你也希望如此,可以在Game视图中选择Play Focused

表格操作
SQLite
目前暂时使用的是SQLite进行表格配置,后续有时间可以改为其他的,看策划的意思.
推荐可以尝试csv格式的Excel表格,并且使用vscode+csv插件进行编辑,既能够满足编辑需求,又能够使用版本控制工具对比和合并
1.游戏中是不会使用SQLite原始表格文件,需要进行一次转换,转换为二进制的才能读取.
  不直接读取的原因:SQLite提供了C#读写的接口,但是只能读写明文的表格文件,无法读取加密的表格文件.所以为了客户端安全,需要进行转换.(虽然也不能说绝对安全,至少提高了破解门槛).
  某些情况下会优先选择读写SQLite原始文件:表格数据量比较大,比如几万几十万行数据.读取转换后的文件会非常耗时,读写SQLite原始表格会快很多.
2.有三个涉及到的目录,SQLite,自动处理工具,自动生成代码.
  SQLite:存放SQLite原始表格文件.db格式的.可以使用DB Browser for SQLite打开.
  自动处理工具:里面目前只有一个转换表格的工具,用于将db转换为.bytes,转换后会存放到Assets/GameResources/Excel目录,名字叫Excel也是因为之前的项目是使用的Excel配置的数据
      配置:复制一份SQLiteToBinaryTableConfigTemplate.txt,改名为SQLiteToBinaryTableConfig.txt,然后打开此文件,将其中的目录改为自己的本地目录
  自动生成代码:这个工具的工程源文件在Codegenerator_SheepVallige中.是用于根据配置自动生成代码,目前只有生成SQLite的表格读写代码.HotFix/Game/DataBase/Excel下的Data和Table目录中的代码都是自动生成的.
      配置:复制一份CodeGenerator_Config_Template.txt,改名为CodeGenerator_Config.txt,然后打开此文件,将其中的目录改为自己的本地目录
所以一般在修改表格后,需要进行以下操作才能在游戏中生效.
1.运行CodeGenerator.exe生成对应的代码(如果表格结构没有改变,也没有新增删除表格,则不需要进行此操作)
2.运行SQLiteToBinaryTable.exe转换表格文件

CSV
其他正在做的项目已经改成csv了,而且也写了一个专用的CSVEditor,后续会放出

添加界面
1.复制一个UI的Prefab,比如改名为UITest.prefab,打开这个prefab,在UITest节点上添加UGUIGenerator组件,点击添加节点,将界面上需要操作的节点拖到面板上,选择好节点类型,然后点击生成代码.

代码示例:

1.对象池的使用
	列表类型的对象池
		离开作用域后会自动回收
		using var a = new ListScope<TestA>(out var obj);
		using var a = new DicScope<TestA>(out var obj);
		using var a = new HashSetScope<TestA>(out var obj);
		持久的列表对象池可以使用,需要自己手动使用UN_LIST进行回收
		LIST(out List<int> obj);
		UN_LIST(out obj);
	类对象的对象池
	  临时使用的对象可以用
	  using var a = new ClassScope<SerializerRead>(out var reader);
	  持久使用的对象使用FrameUtilityILR.CLASS,也是需要手动进行回收.
	  此类对象需要继承自ClassObject,并且需要重写resetProperty函数,将此类的成员变量重置到刚构造结束的状态(这一点非常重要!!!!菜单可以检查出有没有漏掉成员变量)
	Prefab的对象池
	  PrefabPoolManager.createObject或者createObjectAsync,需要使用PrefabPoolManager.destroyObject进行回收,而且不允许在外部对其进行销毁.
	特效的对象池
	  EffectManager.createEffect,实际上也是调用的PrefabPoolManager的方法,只不过针对特效有一些封装,比如播放临时特效
	GameObject的对象池
	  GameObjectPool.newObject,需要使用GameObjectPool.destroyObject进行回收
  
2.字符串
	字符串的操作都在StringUtility有提供函数,包括拼接,转换数字,拆分,查找,文件名相关操作
	对于大量字符串拼接,可以使用MyStringBuilder
	比如using var a = new MyStringBuilderScope(out var builder);
	builder.append("123");
	builder.append(123);
	builder.colorString("FF0000", 123);
	builder.toString();
	对于字符串的转换,可以使用IToS,FToS等方法
	比如 string levelText = "Lv." + IToS(level);

文件
	FileUtility文件相关的操作,读,写,查找,计算MD5等
	比如
	string content = openTxtFileSync("123.txt", true);
	openTxtFileAsync("123.txt", true, (string content)=>{});
	List<string> files = findFiles("aaa/");
	writeFile("123.txt", content);

数学计算
MathUtility,封装了大部分的Mathf方法,也有一些自己写的关于2D或者3D图形的算法

引擎相关工具函数
UnityUtility

Http相关工具函数
HttpUtility,常用的get,post,delete等

时间
TimeUtility

二进制
BinaryUtility

也有很多工具函数是直接以扩展函数的方式实现的,比如ListExtension,DictionaryExtention,HashSetExtension,StringExtension

UI中的一些写法
注册点击事件:
myUGUIObject test;
test.registerCollider(()=>{});
这里定义了一个UI节点对象,然后调用了registerCollider,这个函数中做了三件事情,
1:自动添加一个BoxCollider.
2.向GlobalTouchSystem注册了这个对象.
3.给对象设置一个点击事件的回调.

注册长按事件:
test.registerCollider();
test.addLongPress(()=>{}, 0.5f);
这里表示长按0.5秒以后触发这个回调
registerCollider()空的参数是表示仅添加Collider,并注册对象,没有设置任何事件回调

修改图片
myUGUIImage testImage;
testImage.setSpriteName("123");
这一句的意思是,从testImage身上的Image组件中Sprite的图集中去找到名字为123的Sprite,给设置到Image中.
所以这里的前提条件是
1:prefab中Image组件上需要有一个Sprite,并且这个Sprite是属于一个图集的,无论是SpriteAtlas,还是MultiSprite.
2:Image所在的GameObject上需要有一个ImageAtlasPath组件,因为需要从这个组件中获取到图集文件的路径,不然不知道初始的图集在哪儿.
如果在添加ImageAtlasPath组件时,没有自动找到图集的路径,那可能是Image上没有设置Sprite,或者Sprite没有所属的SpriteAtlas或者MultiSprite.
如果并不涉及到修改图片,只是访问Image组件的一些其他属性,则定义为myUGUIImageSimple会好一些,这样避免去重新加载一次Atlas

设置文本
myUGUITextTMP testText;
testText.setText("123");
testText.setText(123);
这两个方法都可以设置文本,传递int时,内部会自动调用IToS转换为字符串

滑动窗口
myUGUIDragView testDragView;
一般在prefab中的结构为
--Viewport
	--Content
		--Template
在UGUIGenerator面板上会将Content拖拽上去,且选择myUGUIDragView类型

UI中的对象池
一般会将滑动窗口和对象池结合来使用,来实现一些列表的功能,比如当前行会的成员列表
prefab中的结构一般为
--Viewport
	--Content
		--MemberItem
myUGUIDragView testDragView;
protected WindowStructPool<MemberItem> mMakeItemDisplayPool;
mMakeItemDisplayPool.unuseAll();
mMakeItemDisplayPool.newItem();
mMakeItemDisplayPool.autoGridVertical();