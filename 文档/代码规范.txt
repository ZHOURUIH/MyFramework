项目代码规范

空格空行:
1.代码中禁止出现无意义空行.
2.尽量使用注释来代替空行,实在不需要注释的地方,并且与上文逻辑有明显区分的可使用空行分隔
3.在该打空格的地方必须打空格,比如运算符前后,等号前后,for循环中的分号后,if或者for等关键字后不强制打空格,但是尽量还是加上空格.
4.空格和缩进格式可使用Ctrl+K+F让VS使用默认的格式进行调整.

命名规范:
1.类名命名单词首字母大写.
2.类成员变量以m开头,后面的单词首字母大写,必须保证单词拼写正确.
3.函数中的临时变量以小写开头,后面的单词首字母大写.
4.函数名首字母小写.
5.部分情况下使用缩写时允许以大写字母开头,但是仍需要尽量避免这种情况.
6.回调函数以on开头,非回调函数禁止以on开头.且回调函数权限为protected.
7.以set开头的函数应该只用于根据参数设置成员变量的值,而不能做其他的事情.
8.以get开头的函数尽量不要在函数内对成员变量有修改.
9.在函数命名时,明确is,has,can此类单词的含义,一般用于获取一个bool状态时尽量使用is.
10.常量名为全大写,单词之间以下划线分隔.
11.枚举类型名和枚举值的名字与常量一致,全大写,单词之间以下划线分隔,因为枚举本质上也是常量.

代码结构:
1.类成员变量写在类的开头,并且访问权限为保护.
2.不允许在函数之间插入成员变量定义.
3.类函数写在成员变量之后,先写公有函数,然后加分割线,再写保护的函数.
4.不允许出现不同访问权限的函数混合排布.
5.如果一个函数的代码只有一行,则可以将整个函数写成一行,比如简单的的get和set函数,且函数体需要纵向对齐.
6.if下必须添加大括号,即使只有一行也需要添加大括号.
7.成员变量排列按类型来排列,从上到下分别为,Dictionary,List,类对象,string,float,int,bool,枚举.因为一般情况下想要找一个成员变量时很可能已经知道了该变量的类型,所以将同一类的变量放在一起方便查找.
  不需要考虑功能是否相关联.成员变量特别多,功能特别复杂的可以考虑特殊处理.另外这样排布也是为了尽量符合字节对齐的规则.枚举放在最后同样也是因为字节对齐,枚举通常情况下都是1个字节的,所以放在最后比较合适.

常量:
1.禁止在代码中出现意义不明的数字,需要定义常量或者枚举来代替.
2.非显示类的字符串必须定义为常量.比如某个资源的名字等
3.不需要使用readonly标识运行时常量,一般只使用编译时常量即可

注释:
1.提交的代码中禁止出现被注释的代码.
2.禁止使用除了双斜杠以外的注释形式.比如/**/局部注释,///注释
3.行注释双斜杠后需要加一个空格.
4.在代码逻辑不是非常浅显易懂的地方应该添加相应的注释,提高代码阅读效率.
5.尽量在成员变量后添加注释,用于说明此变量用处,以及使用方式等等.
6.成员变量注释或者枚举类型的注释需要对齐.

其他:
1.尽量少使用switch.case少时可使用if代替.
2.提交的代码中禁止出现打印日志.日志打印目前只应该出现在命令的调试信息中,以及部分关键代码部分.
3.允许使用错误日志弹窗提示错误信息.以便及时发现表格或者是资源上不允许出现的错误.
4.界面之间不允许互相访问,也就是说一个界面不应该知道还存在有其他界面,每个界面之间的逻辑应该完全隔离.
5.明确界面与逻辑之间的边界,尽量保证去除界面以后逻辑仍然可以正常运行不受任何影响.
6.界面中不能直接访问网络消息.
7.资源加载时必须考虑资源的生存周期,确保不会产生无人管理的资源.
8.MonoBehaviour目前只用于部分不得不使用此脚本的地方,或者是需要保存编辑器中编辑的参数的情况,比如界面自适应中使用的脚本.
9.避免使用Unity的物理模拟,碰撞事件不使用MonoBehaviour的OnCollisionEnter等通知回调,使用主动的碰撞检测判断.
10.尽量不使用第三方插件.
11.避免直接访问unity组件,使用已封装对象提供的方法进行访问.
12.尽量使用已封装的工具函数,包括文件函数,字符串函数,数学函数,系统函数等,如果有需求也可以添加需要的通用工具函数.
13.避免使用除法,如果可以,使用乘法代替.
14.将具有一定通用性的函数抽象为工具函数放到GameUtility中.
15.谨慎申请堆内存,尽量减少GC.
16.遍历List时尽量使用for,并且定义一个变量存储列表长度,而不是i < list.Count.
17.使用++i,避免使用i++.
18.避免使用Action<>定义委托类型的函数参数,尽量显式定义委托类型.
19.尽量避免使用一些作用不是很大并且使用非常少的语法形式,尽量与整体代码风格保持一致.
20.使用浮点数的地方需要显式表示为浮点数,而不是在需要浮点数的地方使用整数.
21.避免产生警告,有警告或者运行时有非正常提示时需要避免.比如Can't add 'GridLayoutGroup' to LeftWidget because a 'VerticalLayoutGroup' is already added to the game object!
22.尽量不使用get/set属性,显式添加getXX或者setXX代替.
23.避免使用协程,仅在部分只能使用协程的情况下才用.
24.一行代码的长度控制在130个字符以内,含缩进.如果超出130个字符,则需要定义临时变量,简化函数或变量名等方式进行优化.
25.避免产生大量大括号嵌套的情况,如果大括号嵌套较多,比如3层,4层,则需要使用提前返回等方式进行优化.
//-------------------------------------------------------------------------------------------------------------------------------------------
布局脚本代码规范
1.命名规范,成员变量,临时变量,函数命名规则
2.窗口变量名应该与窗口名保持一致
3.变量访问权限规范,尽量使用protected,临时的用于避免GC的变量使用private.
4.变量定义顺序应该与布局中顺序相同.
5.在每个非窗口变量后尽量添加注释.
6.成员变量非0初始化尽量写在构造函数中.
8.严格区分构造,assignWindow,init,onReset,onGameState,onShow,onHide用途
构造:用于数据初始化,分配内存.
assignWindow:仅用于查找窗口赋值到成员变量
init:窗口初始化,注册窗口事件.
onReset:将布局运行过程中可能会变化的成员变量重置到刚初始化完成时的状态.
onGameState:根据游戏中逻辑状态和数据设置界面显示.
onShow:仅用于执行界面显示时的动态效果.
onHide:仅用于执行界面隐藏时的动态效果.或者其他关闭时的仅界面逻辑
9.assignWindow中不能查找窗口赋值给临时变量
10.assignWindow中不允许使用new分配内存
11.仅在当前布局使用的函数应该设置为protected,并且放到脚本文件的最下方
12.尽量避免使用region
13.所有加载资源或者创建对象的地方必须有统一的创建和销毁
14.减少不必要的函数创建
15.避免使用反射.
16.脚本中使用的内部类需要放到单独的代码文件中,放到InnerClass中
17.脚本内部类需要提供构造,assignWindow,init,reset方法.
18.脚本内部类构造函数只允许有一个LayoutScript参数
19.脚本内部类assignWindow,init规范与脚本一致
20.脚本中除了onGameState以外,其他地方尽量不能引用除了脚本自身以外的游戏逻辑对象,也不能引用其他脚本.包括不能收发网络消息
21.触发界面事件时尽量通过命令的方式向外发送事件
22.成员变量排列顺序,从上往下,窗口对象变量,列表,内部类对象,结构体,枚举,string,float,bool,int
23.避免使用lambda表达式编写匿名函数,使用常规函数代替
24.删除已注释代码
25.事件注册回调不允许对应多个窗口,事件注册回调中不允许根据点击物体来执行不同的逻辑
26.谨慎使用new申请堆内存,确保不申请仅临时使用且执行频率较高的堆内存
27.在适当的地方使用?.和?.Invoke简化代码
28.所有内部类尽量是GameBase的子类
29.善用窗口对象池重复利用对象
30.窗口或变量命名避免使用简写,只有在名称比较长时使用简写
31.尽量添加注释
32.避免添加无用空行

以上部分规范在项目中有菜单功能进行代码检查,最优情况是完全代码检查后没有任何报错.